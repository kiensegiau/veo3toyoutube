const fetch = require('node-fetch');
const fs = require('fs');
const path = require('path');
const { exec } = require('child_process');
const { promisify } = require('util');

const execAsync = promisify(exec);

// ChatGPT API configuration
const OPENAI_API_KEY = process.env.OPENAI_API_KEY || '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';

/**
 * T·∫°o video 32s v·ªõi transcript MH370 v√† h√¨nh ·∫£nh ƒë·ªìng nh·∫•t
 */
async function createMH370Video32s() {
    try {
        console.log('üöÄ [MH370] T·∫°o video 32s v·ªõi transcript MH370...');
        
        const serverUrl = 'http://localhost:8888';
        const youtubeUrl = 'https://youtu.be/52ru0qDc0LQ?si=zahSVRyDiQy7Jd6H';
        const outputDir = './temp/mh370-32s-video';
        
        // T·∫°o th∆∞ m·ª•c output
        if (!fs.existsSync(outputDir)) {
            fs.mkdirSync(outputDir, { recursive: true });
        }
        
        // Step 1: L·∫•y transcript t·ª´ YouTube
        console.log('üìù [Step 1] L·∫•y transcript t·ª´ YouTube MH370...');
        const transcriptResponse = await fetch(`${serverUrl}/api/get-transcript`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                url: youtubeUrl,
                lang: 'vi'
            })
        });
        
        const transcriptResult = await transcriptResponse.json();
        console.log('üìù [Step 1] Transcript result:', transcriptResult.success ? '‚úÖ Success' : '‚ùå Failed');
        
        if (!transcriptResult.success) {
            throw new Error(`Kh√¥ng th·ªÉ l·∫•y transcript: ${transcriptResult.message}`);
        }
        
        const transcriptText = typeof transcriptResult.transcript === 'string' ? 
            transcriptResult.transcript : 
            JSON.stringify(transcriptResult.transcript);
        
        console.log(`üìù [Step 1] Transcript: ${transcriptText.substring(0, 300)}...`);
        
        // Step 2: ChatGPT ph√¢n t√≠ch v√† t·∫°o prompt ƒë·ªìng nh·∫•t cho 4 segments
        console.log('ü§ñ [Step 2] ChatGPT t·∫°o prompt ƒë·ªìng nh·∫•t cho 4 segments...');
        
        const chatGPTResponse = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${OPENAI_API_KEY}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                model: 'gpt-4o-mini',
                messages: [
                    { 
                        role: "system", 
                        content: `B·∫°n l√† chuy√™n gia t·∫°o prompt video cho Veo3 v·ªõi kh·∫£ nƒÉng t·∫°o h√¨nh ·∫£nh ƒë·ªìng nh·∫•t v√† li·ªÅn m·∫°ch.

Nhi·ªám v·ª•: D·ª±a tr√™n transcript v·ªÅ MH370, t·∫°o 4 prompts cho 4 segments 8s (t·ªïng 32s) v·ªõi:
1. H√åNH ·∫¢NH ƒê·ªíNG NH·∫§T v·ªÅ ch·ªß ƒë·ªÅ MH370
2. M√ÄU S·∫ÆC NH·∫§T QU√ÅN (xanh d∆∞∆°ng ƒë·∫≠m, ƒëen, tr·∫Øng)
3. PHONG C√ÅCH T√ÄI LI·ªÜU ƒêI·ªÄU TRA
4. CHUY·ªÇN TI·∫æP M∆Ø·ª¢T M√Ä gi·ªØa c√°c segments
5. CHI TI·∫æT C·ª§ TH·ªÇ cho t·ª´ng segment

Tr·∫£ v·ªÅ JSON format:
{
    "overallTheme": "Ch·ªß ƒë·ªÅ t·ªïng th·ªÉ",
    "colorScheme": "B·∫£ng m√†u ch√≠nh",
    "visualStyle": "Phong c√°ch visual",
    "segments": [
        {
            "timeRange": "0-8s",
            "focus": "N·ªôi dung ch√≠nh c·ªßa segment",
            "prompt": "Prompt chi ti·∫øt cho Veo3 v·ªõi h√¨nh ·∫£nh c·ª• th·ªÉ"
        },
        {
            "timeRange": "8-16s", 
            "focus": "N·ªôi dung ch√≠nh c·ªßa segment",
            "prompt": "Prompt chi ti·∫øt cho Veo3 v·ªõi h√¨nh ·∫£nh c·ª• th·ªÉ"
        },
        {
            "timeRange": "16-24s",
            "focus": "N·ªôi dung ch√≠nh c·ªßa segment", 
            "prompt": "Prompt chi ti·∫øt cho Veo3 v·ªõi h√¨nh ·∫£nh c·ª• th·ªÉ"
        },
        {
            "timeRange": "24-32s",
            "focus": "N·ªôi dung ch√≠nh c·ªßa segment",
            "prompt": "Prompt chi ti·∫øt cho Veo3 v·ªõi h√¨nh ·∫£nh c·ª• th·ªÉ"
        }
    ]
}` 
                    },
                    { 
                        role: "user", 
                        content: `D·ª±a tr√™n transcript v·ªÅ MH370 n√†y, t·∫°o 4 prompts ƒë·ªìng nh·∫•t cho video 32s:

TRANSCRIPT:
${transcriptText}

Y√äU C·∫¶U:
- M·ªói segment 8s ph·∫£i c√≥ h√¨nh ·∫£nh c·ª• th·ªÉ v·ªÅ MH370
- ƒê·ªìng nh·∫•t v·ªÅ m√†u s·∫Øc v√† phong c√°ch
- Chuy·ªÉn ti·∫øp m∆∞·ª£t m√† gi·ªØa c√°c segments
- Chi ti·∫øt c·ª• th·ªÉ: m√°y bay, bi·ªÉn, v·ªá tinh, ƒë·ªì h·ªça ƒëi·ªÅu tra` 
                    }
                ],
                max_tokens: 2000,
                temperature: 0.7
            })
        });
        
        const chatGPTResult = await chatGPTResponse.json();
        console.log('ü§ñ [Step 2] ChatGPT result:', chatGPTResult.choices ? '‚úÖ Success' : '‚ùå Failed');
        
        if (!chatGPTResult.choices) {
            throw new Error('ChatGPT kh√¥ng tr·∫£ v·ªÅ k·∫øt qu·∫£');
        }
        
        const analysisText = chatGPTResult.choices[0].message.content;
        console.log(`ü§ñ [Step 2] Ph√¢n t√≠ch ho√†n ch·ªânh:`);
        console.log(analysisText);
        
        // Parse JSON t·ª´ response
        let analysis;
        try {
            const jsonMatch = analysisText.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                analysis = JSON.parse(jsonMatch[0]);
                console.log(`‚úÖ [Step 2] ƒê√£ ph√¢n t√≠ch: ${analysis.overallTheme}`);
                console.log(`‚úÖ [Step 2] M√†u s·∫Øc: ${analysis.colorScheme}`);
                console.log(`‚úÖ [Step 2] Phong c√°ch: ${analysis.visualStyle}`);
            } else {
                throw new Error('No JSON found in response');
            }
        } catch (parseError) {
            console.warn(`‚ö†Ô∏è [Step 2] Kh√¥ng th·ªÉ parse JSON, t·∫°o mock analysis`);
            
            // Mock analysis fallback
            analysis = {
                overallTheme: "MH370 Investigation Documentary",
                colorScheme: "Deep blue, black, white",
                visualStyle: "Documentary investigation style",
                segments: [
                    {
                        timeRange: "0-8s",
                        focus: "MH370 disappearance overview",
                        prompt: "Create a documentary-style video showing Malaysia Airlines Boeing 777-200ER flying over dark ocean waters at night. Deep blue and black color scheme with white text overlays showing flight path. Professional investigation graphics with satellite imagery background."
                    },
                    {
                        timeRange: "8-16s",
                        focus: "Search efforts and satellite data",
                        prompt: "Show detailed satellite imagery and search operations in the Indian Ocean. Deep blue ocean waters with search vessels and aircraft. Investigation graphics showing radar data and flight path analysis. Professional documentary style with blue and white color scheme."
                    },
                    {
                        timeRange: "16-24s",
                        focus: "Ocean Infinity search operations",
                        prompt: "Display Ocean Infinity's advanced search technology and underwater vehicles searching the ocean floor. Deep blue underwater scenes with high-tech equipment. Professional investigation graphics showing search patterns and sonar data."
                    },
                    {
                        timeRange: "24-32s",
                        focus: "Current investigation status",
                        prompt: "Show current investigation status with updated search data and ongoing efforts. Deep blue ocean with investigation graphics and timeline. Professional documentary conclusion with blue and white color scheme, showing continued search efforts."
                    }
                ]
            };
        }
        
        // Step 3: T·∫°o 4 video Veo3 song song v·ªõi prompts ƒë·ªìng nh·∫•t
        console.log('üé¨ [Step 3] T·∫°o 4 video Veo3 song song v·ªõi prompts ƒë·ªìng nh·∫•t...');
        
        const veo3Promises = analysis.segments.map(async (segment, index) => {
            console.log(`üé¨ [Step 3] T·∫°o video segment ${index + 1}: ${segment.timeRange}`);
            console.log(`üé¨ [Step 3] Focus: ${segment.focus}`);
            console.log(`üé¨ [Step 3] Prompt: ${segment.prompt.substring(0, 100)}...`);
            
            try {
                const veo3Response = await fetch(`${serverUrl}/api/create-video`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        input: segment.prompt,
                        prompt: segment.prompt
                    })
                });
                
                const veo3Result = await veo3Response.json();
                
                if (veo3Result.success) {
                    console.log(`‚úÖ [Step 3] Segment ${index + 1} Veo3: ${veo3Result.operationName}`);
                    return {
                        segmentIndex: index,
                        timeRange: segment.timeRange,
                        focus: segment.focus,
                        prompt: segment.prompt,
                        operationId: veo3Result.operationName,
                        success: true
                    };
                } else {
                    console.log(`‚ùå [Step 3] Segment ${index + 1} th·∫•t b·∫°i: ${veo3Result.message}`);
                    return {
                        segmentIndex: index,
                        timeRange: segment.timeRange,
                        error: veo3Result.message,
                        success: false
                    };
                }
            } catch (error) {
                console.log(`‚ùå [Step 3] Segment ${index + 1} l·ªói: ${error.message}`);
                return {
                    segmentIndex: index,
                    timeRange: segment.timeRange,
                    error: error.message,
                    success: false
                };
            }
        });
        
        // Ch·ªù t·∫•t c·∫£ Veo3 requests ho√†n th√†nh
        const veo3Results = await Promise.all(veo3Promises);
        const successfulOperations = veo3Results.filter(r => r.success);
        
        console.log(`‚úÖ [Step 3] ƒê√£ g·ª≠i ${successfulOperations.length}/4 Veo3 requests`);
        console.log(`üöÄ [Step 3] T·∫•t c·∫£ Veo3 ƒëang ch·∫°y ng·∫ßm...`);
        
        // Step 4: Ch·∫°y ng·∫ßm - ki·ªÉm tra v√† t·∫£i video khi s·∫µn s√†ng
        console.log(`üîÑ [Step 4] Ch·∫°y ng·∫ßm - ki·ªÉm tra v√† t·∫£i video khi s·∫µn s√†ng...`);
        
        const downloadPromises = successfulOperations.map(async (veo3Result) => {
            const operationId = veo3Result.operationId;
            console.log(`üîÑ [Step 4] Monitor operation: ${operationId}`);
            
            // Polling ƒë·ªÉ ki·ªÉm tra tr·∫°ng th√°i
            let attempts = 0;
            const maxAttempts = 60; // T·ªëi ƒëa 60 l·∫ßn (5 ph√∫t)
            
            while (attempts < maxAttempts) {
                try {
                    const statusResponse = await fetch(`${serverUrl}/api/check-status`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            operationName: operationId
                        })
                    });
                    
                    const statusResult = await statusResponse.json();
                    
                    if (statusResult.success && statusResult.videoStatus === 'COMPLETED' && statusResult.videoUrl) {
                        console.log(`‚úÖ [Step 4] Operation ${operationId} ƒë√£ ho√†n th√†nh!`);
                        
                        // T·∫£i video
                        const downloadResponse = await fetch(`${serverUrl}/api/tts/download`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                audioUrl: statusResult.videoUrl,
                                filename: `mh370_segment_${veo3Result.segmentIndex}_${Date.now()}.mp4`
                            })
                        });
                        
                        const downloadResult = await downloadResponse.json();
                        
                        if (downloadResult.success) {
                            console.log(`‚úÖ [Step 4] Segment ${veo3Result.segmentIndex + 1} ƒë√£ t·∫£i v·ªÅ`);
                            console.log(`‚úÖ [Step 4] Video path: ${downloadResult.outPath}`);
                            return {
                                segmentIndex: veo3Result.segmentIndex,
                                timeRange: veo3Result.timeRange,
                                focus: veo3Result.focus,
                                path: downloadResult.outPath,
                                operationId: operationId,
                                success: true
                            };
                        } else {
                            console.log(`‚ùå [Step 4] Segment ${veo3Result.segmentIndex + 1} t·∫£i v·ªÅ th·∫•t b·∫°i: ${downloadResult.message}`);
                            return {
                                segmentIndex: veo3Result.segmentIndex,
                                error: 'Download failed',
                                success: false
                            };
                        }
                    } else if (statusResult.success && statusResult.videoStatus === 'PENDING') {
                        console.log(`‚è≥ [Step 4] Operation ${operationId} ƒëang x·ª≠ l√Ω... (attempt ${attempts + 1})`);
                        attempts++;
                        await new Promise(resolve => setTimeout(resolve, 5000)); // Ch·ªù 5 gi√¢y
                    } else {
                        console.log(`‚ùå [Step 4] Operation ${operationId} th·∫•t b·∫°i ho·∫∑c kh√¥ng t√¨m th·∫•y`);
                        return {
                            segmentIndex: veo3Result.segmentIndex,
                            error: 'Operation failed',
                            success: false
                        };
                    }
                } catch (error) {
                    console.warn(`‚ö†Ô∏è [Step 4] L·ªói ki·ªÉm tra operation ${operationId}:`, error.message);
                    attempts++;
                    await new Promise(resolve => setTimeout(resolve, 5000));
                }
            }
            
            console.log(`‚è∞ [Step 4] Operation ${operationId} timeout sau ${maxAttempts} attempts`);
            return {
                segmentIndex: veo3Result.segmentIndex,
                error: 'Timeout',
                success: false
            };
        });
        
        // Ch·ªù t·∫•t c·∫£ video ƒë∆∞·ª£c t·∫£i v·ªÅ
        console.log(`‚è≥ [Step 4] Ch·ªù t·∫•t c·∫£ video ƒë∆∞·ª£c t·∫£i v·ªÅ...`);
        const videoFiles = await Promise.all(downloadPromises);
        const successfulVideos = videoFiles.filter(v => v.success);
        
        console.log(`‚úÖ [Step 4] ƒê√£ t·∫£i ${successfulVideos.length}/4 video`);
        
        // Step 5: Gh√©p video th√†nh 1 video k·∫øt qu·∫£
        if (successfulVideos.length > 0) {
            console.log(`üé¨ [Step 5] Gh√©p ${successfulVideos.length} video th√†nh 1 video k·∫øt qu·∫£...`);
            
            // S·∫Øp x·∫øp theo th·ª© t·ª±
            successfulVideos.sort((a, b) => a.segmentIndex - b.segmentIndex);
            
            // Ki·ªÉm tra c√°c file video t·ªìn t·∫°i
            const validVideoFiles = successfulVideos.filter(video => {
                if (!video.path || !fs.existsSync(video.path)) {
                    console.warn(`‚ö†Ô∏è [Step 5] File video kh√¥ng t·ªìn t·∫°i: ${video.path}`);
                    return false;
                }
                return true;
            });
            
            if (validVideoFiles.length === 0) {
                throw new Error('Kh√¥ng c√≥ file video h·ª£p l·ªá ƒë·ªÉ gh√©p');
            }
            
            console.log(`üìù [Step 5] C√≥ ${validVideoFiles.length} file video h·ª£p l·ªá ƒë·ªÉ gh√©p`);
            
            // T·∫°o file list cho ffmpeg
            const listPath = path.join(outputDir, 'mh370_video_list.txt');
            const listContent = validVideoFiles.map(video => {
                const absolutePath = path.resolve(video.path);
                const normalizedPath = absolutePath.replace(/\\/g, '/');
                return `file '${normalizedPath}'`;
            }).join('\n');
            
            console.log(`üìù [Step 5] T·∫°o file list: ${listPath}`);
            fs.writeFileSync(listPath, listContent, 'utf8');
            
            // Gh√©p video
            const finalVideoPath = path.join(outputDir, `mh370_32s_final_${Date.now()}.mp4`);
            const mergeCmd = `ffmpeg -f concat -safe 0 -i "${listPath}" -c copy "${finalVideoPath}"`;
            
            await execAsync(mergeCmd);
            
            console.log(`‚úÖ [Step 5] ƒê√£ gh√©p video th√†nh: ${finalVideoPath}`);
            
            // L∆∞u k·∫øt qu·∫£ ho√†n ch·ªânh
            const finalResult = {
                timestamp: new Date().toISOString(),
                youtubeUrl: youtubeUrl,
                transcript: transcriptText,
                overallTheme: analysis.overallTheme,
                colorScheme: analysis.colorScheme,
                visualStyle: analysis.visualStyle,
                segmentsCreated: analysis.segments.length,
                veo3OperationsSent: successfulOperations.length,
                videosDownloaded: successfulVideos.length,
                finalVideo: finalVideoPath,
                segments: analysis.segments,
                veo3Results: veo3Results,
                videoFiles: successfulVideos,
                outputDir: outputDir
            };
            
            const resultPath = path.join(outputDir, 'mh370-32s-result.json');
            fs.writeFileSync(resultPath, JSON.stringify(finalResult, null, 2));
            
            console.log(`üìä [Step 5] ƒê√£ l∆∞u k·∫øt qu·∫£ v√†o: ${resultPath}`);
            
            console.log('üéâ [MH370] Ho√†n th√†nh t·∫°o video 32s v·ªõi transcript MH370!');
            console.log(`üéâ [MH370] Video k·∫øt qu·∫£: ${finalVideoPath}`);
            console.log(`üéâ [MH370] Ch·ªß ƒë·ªÅ: ${analysis.overallTheme}`);
            console.log(`üéâ [MH370] M√†u s·∫Øc: ${analysis.colorScheme}`);
            
            return {
                success: true,
                result: finalResult
            };
            
        } else {
            throw new Error('Kh√¥ng c√≥ video n√†o ƒë∆∞·ª£c t·∫£i v·ªÅ ƒë·ªÉ gh√©p');
        }
        
    } catch (error) {
        console.error(`‚ùå [MH370] L·ªói:`, error.message);
        return {
            success: false,
            error: error.message
        };
    }
}

console.log('üöÄ [START] T·∫°o video 32s v·ªõi transcript MH370...');
createMH370Video32s().then(result => {
    if (result.success) {
        console.log('üéâ [MH370] Ho√†n th√†nh th√†nh c√¥ng!');
        console.log(`üéâ [MH370] Video: ${result.result.finalVideo}`);
    } else {
        console.log(`‚ùå [MH370] Th·∫•t b·∫°i: ${result.error}`);
    }
});
